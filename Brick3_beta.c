#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     MICC,           sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     motorR,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorL,        tmotorTetrix, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers\hitechnic-colour-v2.h"
#include "drivers\microinfinity-cruizcore.h"


void MICCcalibrate() {
	while (MICCreadRelativeHeading(MICC) != 0) {
		MICCsetRange8G(MICC);
		MICCreset(MICC);
		wait1Msec(1000);
	}
	PlaySound(soundFastUpwardTones);
	while(bSoundActive) EndTimeSlice();
}

void setupHighSpeedLink(const bool bMaster) {
	nxtEnableHSPort();
nxtHS_Mode = bMaster ? hsMsgModeMaster : hsMsgModeSlave;
	return;
}

long nRcvChars = 0;
unsigned char front_sonar, right_sonar, robotIsOnBase;

void Receive() {
	int nNumbBytesAvail;
	int nNumbBytesToRead;
	int nNumbBytesActuallyRead;
	ubyte BytesRead[3];
	while (true) {
		nNumbBytesAvail = nxtGetAvailHSBytes();
		if (nNumbBytesAvail <= 0) {
			nNumbBytesActuallyRead = 0;
			wait1Msec(5);
			continue;
		}
		if (nNumbBytesAvail < sizeof(BytesRead)) nNumbBytesToRead = nNumbBytesAvail;
		else nNumbBytesToRead = sizeof(BytesRead);
		nNumbBytesActuallyRead = nxtReadRawHS(& BytesRead[0], nNumbBytesToRead);
		nRcvChars += nNumbBytesActuallyRead;
		wait1Msec(5);
		front_sonar = BytesRead[0];
		robotIsOnBase = BytesRead[1];
		right_sonar = BytesRead[2];
		wait1Msec(5);
	}
}

task RS485Receive() {
	eraseDisplay();
	bNxtLCDStatusDisplay = true;
	setupHighSpeedLink(true);
	nxtHS_Mode = hsRawMode;
	Receive();
}

long angleTransform(long alpha) {
	if (alpha < 0) alpha += 36000;
	if (alpha >= 36000) alpha -= 36000;
	return alpha;
}

//#define RotateMaxSpeed 							50
//#define RotateMinSpeed              10
//#define RotateMinError 							15
//#define RotateAccelerationFactor 		550
//#define RotateDegreesToAccelerate   30

//#define RotateDecelerationAngle 4500
//#define RotateMinSpeedAngle 1500

//const int RotateDeccelerationFactor = (RotateDecelerationAngle - RotateMinSpeedAngle) / (RotateMaxSpeed - RotateMinSpeed);

//long RobotDirection = 0;

//long robotAngle, error;
//	int power;

//void Rotate(int angle)
//{


//	RobotDirection = angleTransform(RobotDirection + angle * 100);
//	robotAngle = angleTransform(MICCreadRelativeHeading(MICC));
//	error = RobotDirection - robotAngle;
//	while (abs(error) > RotateMinError)
//	{
//		robotAngle = angleTransform(MICCreadRelativeHeading(MICC));
//		error = RobotDirection - robotAngle;
//		if (error >= 18000) error = error - 36000;
//		if (error <= -18000) error = error + 36000;
//		if (abs(error) <= RotateDecelerationAngle)
//		{
//			if (abs(error) <= RotateMinSpeedAngle)
//				power = RotateMinSpeed;
//			else
//				power = (abs(error) - RotateMinSpeedAngle) / RotateDeccelerationFactor;

//		}
//		if (power > RotateMaxSpeed) power = RotateMaxSpeed;
//		motor[motorL] = power * sgn(error);
//		motor[motorR] = -power * sgn(error);
//	}
//	motor[motorL] = 0;
//	motor[motorR] = 0;
//}


#define RotateMaxSpeed 							100
#define RotateMinError 							25
#define RotateAccelerationFactor 		675




long RobotDirection = 0;
void Rotate(int angle) {

	long robotAngle, error;
	int power;
	RobotDirection = angleTransform(RobotDirection + angle * 100);
	robotAngle = angleTransform(MICCreadRelativeHeading(MICC));
	while (abs(RobotDirection - robotAngle) > RotateMinError)	{
		robotAngle = angleTransform(MICCreadRelativeHeading(MICC));
		error = RobotDirection - robotAngle;
		if (error > 18000) error = error - 36000;
		if (error < -18000) error = error + 36000;
		if (abs(error) <= 3000) {
			if (abs(error) <= 1000) power = 5;
			else power = 15 + ((abs(error) - 1000) / RotateAccelerationFactor);
		}
		else power = 30 + ((abs(error) - 3000) / RotateAccelerationFactor);
		if (power > RotateMaxSpeed) power = RotateMaxSpeed;
		motor[motorL] = power * sgn(error);
		motor[motorR] = -power * sgn(error);
	}
	motor[motorL] = 0;
	motor[motorR] = 0;
}


long moveAngleTransform(long alpha) {
	if(alpha > 18000) alpha -= 36000;
	if(alpha < -18000) alpha += 36000;
	return alpha;
}

#define MoveMinError 22
#define MoveAccelerationLength 15
#define MoveAngleFactor 3
#define MoveDecelerationLength 25
#define MoveMaxSpeed 100
#define MoveMinSpeed 10

#define wheeldiameter  10.4
#define robotwidth 41.5
#define encoderrotation 1440

#define SonarAccelerationFactor      1.5
#define SonarSafeZoneLength 				 15

/*const*/ float encoderconst = encoderrotation / (wheeldiameter * PI);
/*const*/ int EncoderDecelerationLength = MoveDecelerationLength * encoderconst;
const int EncoderAccelerationFactor = (MoveAccelerationLength * encoderconst) / (MoveMaxSpeed - MoveMinSpeed);
/*const*/int EncoderDecelerationFactor = EncoderDecelerationLength / (MoveMaxSpeed - MoveMinSpeed);
/*const*///float SonarDecelerationFactor = (MoveMaxSpeed - MoveMinSpeed) / MoveDecelerationLength;
/*const*/unsigned int SonarDecelerationLength = SonarSafeZoneLength+MoveDecelerationLength;
bool MoveSonarTriggered;

long errorL, errorR, encoderL, encoderR;
short MoveAngleError, powerL = 0, powerR = 0;

void Move(int length)
{

	long encoderLength = length * encoderconst;
	motor[motorL] = 0;
	motor[motorR] = 0;
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	nMotorEncoderTarget[motorL] = encoderLength;
	nMotorEncoderTarget[motorR] = encoderLength;
	do {
		encoderL = nMotorEncoder[motorL];
		encoderR = nMotorEncoder[motorR];
		if (front_sonar < SonarDecelerationLength)
		{
			errorL = (front_sonar - SonarSafeZoneLength) * encoderconst;
			errorR = errorL;
			MoveAngleError = 0;
			MoveSonarTriggered = true;
		}
		else
		{
			errorL = encoderLength - encoderL;
			errorR = encoderLength - encoderR;
			MoveAngleError = (moveAngleTransform(MICCreadRelativeHeading(MICC) - RobotDirection) / 100) * MoveAngleFactor;
		}
		if(abs(errorL) > EncoderDecelerationLength)
		{
			powerL = MoveMinSpeed * sgn(errorL) + encoderL / EncoderAccelerationFactor;
			if (abs(powerL) > MoveMaxSpeed) powerL = MoveMaxSpeed;
			powerL -= MoveAngleError;
		}
		else powerL = MoveMinSpeed * sgn(errorL) + errorL / EncoderDecelerationFactor;
		if(abs(errorR) > EncoderDecelerationLength)
		{
			powerR = MoveMinSpeed * sgn(errorR) + encoderR / EncoderAccelerationFactor;
			if (abs(powerR) > MoveMaxSpeed) powerR = MoveMaxSpeed;
			powerR += MoveAngleError;
		}
		else powerR = MoveMinSpeed * sgn(errorR) + errorR / EncoderDecelerationFactor;





		motor[motorR] = powerR;
		motor[motorL] = powerL;
	}while(((abs(errorL) > MoveMinError) || (abs(errorR) > MoveMinError)) && ((powerL != 0) || (powerR != 0)) && (front_sonar > SonarSafeZoneLength));
	motor[motorR] = 0;
	motor[motorL] = 0;
}
void GoHomeClockWise()
{
	RobotDirection = 9000;
	Rotate(0);
	Move(250);
				if(robotIsOnBase == 0)
	  {
		Rotate(90);
		Move(250);
		Rotate(90);
	  }
	  else
	  	Rotate(180);
}
void GoHomeCounterClockWise()
{

		RobotDirection = 18000;
		Rotate(0);
		Move(250);
				if(robotIsOnBase == 0)
	  {
		Rotate(-90);
		Move(250);
		Rotate(-90);
	  }
	  else
	  	Rotate(-180);
}
void GoHome()
{
	while(robotIsOnBase == 0)
	{
		GoHomeCounterClockWise();
		if(robotIsOnBase == 0)
		{
			Move(100);
			GoHomeClockWise();
		}
	}
	if(RobotDirection!=0)
	{
				RobotDirection = 0;
		Rotate(0);
	}
	ClearTimer(T4);
}


void RandomMovement()
{

	ClearTimer(T1);
	while(true)
	{
		Move(354);
		if(time100[T1] > 550)
		{
			GoHome();
			ClearTimer(T1);
		}
		RobotDirection += 4500 * ((rand() % 8)-4);
		Rotate(0);
		if(time100[T2]>1600)
		{
			GoHome();
			ClearTimer(T2);
		}
	}
}
void SmartSquare(short n)
{
	for(int i = 1; i<=4; i++)
	{
		Move(n);
		Rotate(-90);
    GoHome();
	}
}

#define MinLength 65
#define MaxLength 220
void RandomRectangle()
{
ubyte length = rand() % (MaxLength - MinLength) + MinLength;
ubyte width  = rand() % (MaxLength - MinLength) + MinLength;
Move(length);
Rotate(-90);
Move(width);
GoHome();
}
void Square(short n)
{
	Move(n);
	Rotate(-90);
	Move(n);
  GoHome();
}
void Triangle(short n)
{
	n *= sqrt(2);
	Rotate(-45);
	Move(n);
	GoHome();
}
task main() {
	wait10Msec(20);
	StartTask(RS485Receive);
	MICCcalibrate();
	wait10Msec(50);
	while((nNxtButtonPressed == -1)||(robotIsOnBase == 0)) EndTimeSlice();

  Triangle(100);
  Square(160);
  Square(250);
	while(true){
		RandomRectangle();
	} //Square(200);
}
